// Code generated by gengshell DO NOT EDIT.
// versions:
//  gshell 0.0.1

package main

import (
	"context"
	"encoding/json"

    rpc "{{ .ModuleName }}"

	"github.com/j-tokumori/gshell"

	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
	"google.golang.org/protobuf/proto"
)

// register ...
func register(s *gshell.Shell) {
{{ range $i, $data := .DataList }}
	s.RegisterRPC("{{$data.RPC}}", New{{$data.RPC}}){{end}}
}

{{ range $i, $data := .DataList }}
// {{$data.RPC}} ...
type {{$data.RPC}} rpc.{{$data.Args}}

// Call ...
func (r *{{$data.RPC}}) Call(ctx context.Context, conn grpc.ClientConnInterface) (proto.Message, *metadata.MD, *metadata.MD) {
	client := rpc.New{{$data.ServiceClient}}(conn)
	args := rpc.{{$data.Args}}(*r)
	h := &metadata.MD{}
	t := &metadata.MD{}
	reply, err := client.{{$data.RPC}}(ctx, &args, grpc.Header(h), grpc.Trailer(t))
	if err != nil {
		panic(err)
	}
	return reply, h, t
}

// Key ...
func (r *{{$data.RPC}}) Key() string {
	return "{{$data.RPC}}"
}

// New{{$data.RPC}} ...
func New{{$data.RPC}}(in []byte) gshell.RPC {
	r := &{{$data.RPC}}{}
	err := json.Unmarshal(in, r)
	if err != nil {
		panic(err)
	}
	return r
}

// {{$data.RPC}}Reply ...
func {{$data.RPC}}Reply(c *gshell.Client) *rpc.{{$data.Reply}} {
	if c.Replies["{{$data.RPC}}"] == nil {
		return nil
	}
	return c.Replies["{{$data.RPC}}"].(*rpc.{{$data.Reply}})
}
{{end}}
